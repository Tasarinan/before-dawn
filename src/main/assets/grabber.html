<!DOCTYPE html>
<html>
<head>
  <title>screen grabber</title>
</head>

<body>
  you should never see me
</body>
  
<script>
  const log = require('electron-log');
  const ipcRenderer = require('electron').ipcRenderer;
  const desktopCapturer = require('electron').desktopCapturer;
  const temp = require("temp");
  const os = require("os");
  const fs = require('fs');
  const sourceTypes = {types: ['screen']};

  // https://blog.jcoglan.com/2016/07/12/mutexes-and-javascript/
  var Mutex = function() {
    this._busy  = false;
    this._queue = [];
  };

  Mutex.prototype._dequeue = function() {
    this._busy = true;
    var next = this._queue.shift();

    if (next)
      this._execute(next);
    else
      this._busy = false;
  };

  Mutex.prototype.synchronize = function(task) {
    var self = this;

    return new Promise(function(resolve, reject) {
      self._queue.push([task, resolve, reject]);
      if (!self._busy) self._dequeue();
    });
  };

  Mutex.prototype._execute = function(record) {
    var task    = record[0],
        resolve = record[1],
        reject  = record[2],
        self    = this;

    task().then(resolve, reject).then(function() {
      self._dequeue();
    });
  };

  const mutex = new Mutex();

  var findOrCreate = function(type, screen_id) {
    var el, id;
    id = type + screen_id;

    el = document.getElementById(id);
    if ( el === null ) {
      el = document.createElement(type);
      el.id = id;

      document.body.appendChild(el);
    }

    return el;    
  };

  var getUserMediaError = function(e) {
    log.info('getUserMediaError');
    log.info(e);
  };
  

  var screenToFile = function(video, canvas, photo, s, cb) {
    var tempName = temp.path({dir: os.tmpdir(), suffix:'.png'});
    var width = video.videoWidth;
    var height = video.videoHeight;

    canvas.setAttribute('width', video.videoWidth);
    canvas.setAttribute('height', video.videoHeight);
      
    var context = canvas.getContext('2d');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    context.drawImage(video, 0, 0, width, height);
    
    var data = canvas.toDataURL('image/png');

    context.clearRect(0, 0, canvas.width, canvas.height);
  
    photo.setAttribute('src', data);


    var buffer = Buffer.from(data.split(",")[1], 'base64');
    fs.writeFile(tempName, buffer, () => {
      cb(tempName);
    });          
  }; // screenToFile

  var cleanup = function(video, canvas, photo, s) {
    //
    // stop video capture
    // this seems to handle a problem where CPU load spikes
    // after capture
    //
    if ( s !== undefined ) {
      s.getVideoTracks().forEach((track) => {
        track.stop();
      });
    }
    
    // https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Using_HTML5_audio_and_video
    video.pause();
    video.src = "";
    photo.src = "";
    video.load();
    
    video.remove();
    canvas.remove();
    photo.remove();
  };

  var captureScreen = function(id, width, height) {
    return new Promise((resolve, reject) => {
      var video = findOrCreate('video', id);
      var canvas = findOrCreate('canvas', id);
      var photo = findOrCreate('photo', id);
      var screen_id;

      var screen_opts = {
        audio: false,
        video: {
          mandatory: {
            // fun fact -- you need to use max here
            // @see https://groups.google.com/a/chromium.org/forum/#!topic/chromium-apps/TP_rsnYVQWg
            maxWidth: width,
            maxHeight: height,
            chromeMediaSource: 'desktop'
          }
        }
      };

      // adding muted helps with some security errors
      // @see https://stackoverflow.com/questions/49930680/how-to-handle-uncaught-in-promise-domexception-play-failed-because-the-use
      video.muted = "muted";

      desktopCapturer.getSources(sourceTypes, function(error, sources) {
        console.log(sources);   
        if ( sources.length > 1 ) {
          screen_id = id;
        }
        else {
          screen_id = sources[0].id;
        }

        if ( typeof(screen_id) !== "string" || screen_id.indexOf("screen:") === -1 ) {
          screen_id = "screen:" + id;
        }

        screen_opts.video.mandatory.chromeMediaSourceId = screen_id;
        mutex.synchronize(() => {
          return navigator.mediaDevices.getUserMedia(screen_opts).
            then((mediaStream) => {
              video.srcObject = mediaStream;
              video.play().then(() => {
                screenToFile(video, canvas, photo, mediaStream, (result) => {
                  cleanup(video, canvas, photo, mediaStream);
                  resolve(result);
                });
              });
            }).
            catch((ex) => {
              if ( typeof(window.Sentry) !== "undefined" ) {
                window.Sentry.captureException(ex);
              }

              getUserMediaError(ex);
              cleanup(video, canvas, photo);
            });
        });
      });
    });
  }; // captureScreen

  ipcRenderer.on("request-screenshot", (event, opts) => {
    return captureScreen(opts.id, opts.width, opts.height).then((result) => {
      ipcRenderer.send('screenshot-' + opts.id, {url:result});
    });
  });
</script>
</html>
